# Computer Visioné«˜é¢‘é¢è¯•é¢˜ - å¸¸è§æ•°æ®å¤„ç†å’Œç‰¹å¾å·¥ç¨‹æ–¹æ³•



## **1. å¸¸ç”¨çš„æ•°æ®æ¸…æ´—æ–¹æ³•**

**é¢è¯•è€ƒå¯Ÿç‚¹ï¼š**

- **æ•°æ®æ¸…ç†åœ¨æœºå™¨å­¦ä¹ å’Œè®¡ç®—æœºè§†è§‰ä»»åŠ¡ä¸­çš„é‡è¦æ€§ã€‚**
- **å¦‚ä½•å¤„ç†ç¼ºå¤±å€¼ï¼Ÿ**
- **å¦‚ä½•å¤„ç†å¼‚å¸¸å€¼ï¼Ÿ**
- **èƒ½å¦ä½¿ç”¨åˆé€‚çš„ Python ä»£ç å®žçŽ°è¿™äº›æ–¹æ³•ï¼Ÿ**

------

### **1.1 å¤„ç†ç¼ºå¤±å€¼çš„æ–¹æ³•**

| **æ–¹æ³•**                                  | **æ ¸å¿ƒæ€è·¯**             | **é€‚ç”¨åœºæ™¯**                     |
| ----------------------------------------- | ------------------------ | -------------------------------- |
| **åˆ é™¤ç¼ºå¤±å€¼**                            | ç›´æŽ¥åˆ é™¤åŒ…å«ç¼ºå¤±å€¼çš„æ ·æœ¬ | å½“ç¼ºå¤±å€¼è¾ƒå°‘ä¸”æ•°æ®é‡å……è¶³æ—¶       |
| **å‡å€¼å¡«è¡¥æ³•**                            | ç”¨è¯¥åˆ—çš„å‡å€¼å¡«è¡¥ç¼ºå¤±å€¼   | é€‚ç”¨äºŽæ•°æ®æœä»Žæ­£æ€åˆ†å¸ƒ           |
| **ä¸­ä½æ•°å¡«è¡¥æ³•**                          | ç”¨è¯¥åˆ—çš„ä¸­ä½æ•°å¡«è¡¥ç¼ºå¤±å€¼ | é€‚ç”¨äºŽæ•°æ®å—æžç«¯å€¼å½±å“è¾ƒå¤§çš„æƒ…å†µ |
| **ä¼—æ•°å¡«è¡¥æ³•**                            | ç”¨è¯¥åˆ—çš„ä¼—æ•°å¡«è¡¥ç¼ºå¤±å€¼   | é€‚ç”¨äºŽåˆ†ç±»å˜é‡                   |
| **çƒ­å¡å¡«è¡¥æ³•ï¼ˆKNN æˆ– æœºå™¨å­¦ä¹ æ¨¡åž‹å¡«å……ï¼‰** | é€šè¿‡ç›¸ä¼¼æ•°æ®å¡«å……ç¼ºå¤±å€¼   | é€‚ç”¨äºŽé«˜ç»´æ•°æ®æˆ–ç»“æž„åŒ–æ•°æ®       |

------

### **1.2 å¤„ç†å¼‚å¸¸å€¼çš„æ–¹æ³•**

| **æ–¹æ³•**              | **æ ¸å¿ƒæ€è·¯**                            | **é€‚ç”¨åœºæ™¯**                             |
| --------------------- | --------------------------------------- | ---------------------------------------- |
| **ç»Ÿè®¡åˆ†æžæ³•**        | è®¡ç®—æœ€å¤§æœ€å°å€¼ï¼Œåˆ¤æ–­æ˜¯å¦åˆç†            | é€‚ç”¨äºŽæ•°æ®èŒƒå›´å›ºå®šçš„æƒ…å†µï¼ˆå¦‚å¹´é¾„ã€æ¸©åº¦ï¼‰ |
| **3Ïƒ åŽŸåˆ™**           | è®¡ç®—å‡å€¼ Â± 3 * æ ‡å‡†å·®èŒƒå›´å¤–çš„å€¼ä¸ºå¼‚å¸¸å€¼ | é€‚ç”¨äºŽæ­£æ€åˆ†å¸ƒæ•°æ®                       |
| **ç®±åž‹å›¾ï¼ˆIQRï¼‰åˆ†æž** | è®¡ç®—å››åˆ†ä½è·ï¼ˆIQRï¼‰ç­›é€‰å¼‚å¸¸å€¼           | é€‚ç”¨äºŽæ•°æ®éžæ­£æ€åˆ†å¸ƒçš„æƒ…å†µ               |
| **åŸºäºŽæ¨¡åž‹æ£€æµ‹**      | è®­ç»ƒåˆ†ç±»/å›žå½’æ¨¡åž‹è¯†åˆ«å¼‚å¸¸å€¼             | é€‚ç”¨äºŽå¼‚å¸¸æ¨¡å¼è¾ƒæ˜Žæ˜¾çš„æ•°æ®               |
| **åŸºäºŽè·ç¦»æ£€æµ‹**      | è®¡ç®—æ•°æ®ç‚¹ä¹‹é—´çš„æ¬§å‡ é‡Œå¾—è·ç¦»            | é€‚ç”¨äºŽå¯†åº¦å‡åŒ€çš„èšç±»æ•°æ®                 |
| **åŸºäºŽå¯†åº¦æ£€æµ‹**      | DBSCANã€LOF è®¡ç®—å¯†åº¦å·®å¼‚                | é€‚ç”¨äºŽæ•°æ®å¯†åº¦å˜åŒ–è¾ƒå¤§çš„æƒ…å†µ             |

------

### **ðŸ’¡ ä»£ç ç¤ºä¾‹**

#### **ðŸ“Œ 1. ç¼ºå¤±å€¼å¤„ç†**

```python
import pandas as pd
from sklearn.impute import SimpleImputer

# åˆ›å»ºç¤ºä¾‹æ•°æ®
data = {
    "A": [1, 2, None, 4, 5],
    "B": [None, 2, 3, None, 5],
    "C": [10, 15, 20, 25, None]
}
df = pd.DataFrame(data)

# 1. åˆ é™¤ç¼ºå¤±å€¼
df_dropped = df.dropna()

# 2. å‡å€¼å¡«è¡¥
imputer_mean = SimpleImputer(strategy="mean")
df_filled = pd.DataFrame(imputer_mean.fit_transform(df), columns=df.columns)

print("åŽŸå§‹æ•°æ®ï¼š\n", df)
print("åˆ é™¤ç¼ºå¤±å€¼åŽçš„æ•°æ®ï¼š\n", df_dropped)
print("å¡«å……ç¼ºå¤±å€¼åŽçš„æ•°æ®ï¼š\n", df_filled)
```



#### **ðŸ“Œ 2. å¼‚å¸¸å€¼å¤„ç†ï¼ˆç®±åž‹å›¾/IQR æ–¹æ³•ï¼‰**

```python
import numpy as np

# è®¡ç®— IQR
Q1 = df["C"].quantile(0.25)
Q3 = df["C"].quantile(0.75)
IQR = Q3 - Q1

# ç¡®å®šå¼‚å¸¸å€¼çš„èŒƒå›´
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# è¿‡æ»¤å¼‚å¸¸å€¼
df_no_outliers = df[(df["C"] >= lower_bound) & (df["C"] <= upper_bound)]
print("åŽ»é™¤å¼‚å¸¸å€¼åŽçš„æ•°æ®ï¼š\n", df_no_outliers)
```

------

## **ðŸŽ¯ æ€»ç»“**

### **ðŸ“Œ æ•°æ®æ¸…æ´—**

- ç¼ºå¤±å€¼å¤„ç†ï¼š

  - **åˆ é™¤ç¼ºå¤±å€¼**ï¼šé€‚ç”¨äºŽæ•°æ®é‡å¤§ä¸”ç¼ºå¤±æ¯”ä¾‹ä½Žçš„æƒ…å†µã€‚
  - **å‡å€¼/ä¸­ä½æ•°å¡«è¡¥**ï¼šé€‚ç”¨äºŽæ•°å€¼åž‹æ•°æ®ã€‚
  - **æœºå™¨å­¦ä¹ å¡«è¡¥**ï¼šé€‚ç”¨äºŽé«˜ç»´æ•°æ®ã€‚

- å¼‚å¸¸å€¼å¤„ç†ï¼š

  - **3Ïƒ åŽŸåˆ™**ï¼šé€‚ç”¨äºŽæ­£æ€åˆ†å¸ƒæ•°æ®ã€‚
  - **IQR ç®±åž‹å›¾**ï¼šé€‚ç”¨äºŽéžæ­£æ€åˆ†å¸ƒæ•°æ®ã€‚
  - **åŸºäºŽæ¨¡åž‹/èšç±»çš„æ–¹æ³•**ï¼šé€‚ç”¨äºŽå¤æ‚æ•°æ®ã€‚

  

## **2. ç›®æ ‡æ£€æµ‹ä¸­çš„æ•°æ®å¢žå¼ºæ–¹æ³•**

**é¢è¯•è€ƒå¯Ÿç‚¹ï¼š**

- **æ•°æ®å¢žå¼ºå¯¹äºŽç›®æ ‡æ£€æµ‹ä»»åŠ¡çš„å¿…è¦æ€§ã€‚**
- **èƒ½å¦æ­£ç¡®å¤„ç† Bounding Box çš„å˜åŒ–ï¼Ÿ**
- **å¦‚ä½•ä½¿ç”¨ Python ä»£ç å®žçŽ°æ•°æ®å¢žå¼ºï¼Ÿ**

------

### **2.1 ç›®æ ‡æ£€æµ‹çš„å¸¸è§æ•°æ®å¢žå¼ºæ–¹æ³•**

| **æ–¹æ³•**                                 | **å½±å“**           | **Bounding Box å¤„ç†**         |
| ---------------------------------------- | ------------------ | ----------------------------- |
| **è£å‰ª (Crop)**                          | æ”¾å¤§æˆ–ç¼©å°ç›®æ ‡åŒºåŸŸ | éœ€è¦é‡æ–°è®¡ç®—ç›®æ ‡æ¡†            |
| **å¹³ç§» (Translation)**                   | ä½¿ç›®æ ‡åç§»ä¸€å®šåƒç´  | ç›®æ ‡æ¡†éšå›¾åƒç§»åŠ¨              |
| **æ—‹è½¬ (Rotation)**                      | ç›®æ ‡å€¾æ–œ           | éœ€æ—‹è½¬ç›®æ ‡æ¡†                  |
| **é•œåƒ (Flip - Horizontal/Vertical)**    | å·¦å³ç¿»è½¬ç›®æ ‡       | æ°´å¹³ç¿»è½¬æ—¶éœ€è°ƒæ•´ç›®æ ‡æ¡† X åæ ‡ |
| **é¢œè‰²å˜åŒ– (Brightness, Contrast, Hue)** | å½±å“è§†è§‰æ„ŸçŸ¥       | ä¸å½±å“ç›®æ ‡æ¡†                  |
| **æ·»åŠ å™ªå£° (Gaussian Noise)**            | ä½¿æ¨¡åž‹æ›´é²æ£’       | ä¸å½±å“ç›®æ ‡æ¡†                  |

------

### **OpenCV ä»‹ç»**

OpenCV æ˜¯ä¸€ä¸ªç”¨äºŽ **è®¡ç®—æœºè§†è§‰ï¼ˆComputer Visionï¼‰å’Œå›¾åƒå¤„ç†** çš„å¼€æºåº“ï¼Œæ”¯æŒå¤šç§ç¼–ç¨‹è¯­è¨€ï¼ˆPythonã€C++ã€Java ç­‰ï¼‰ï¼Œä¸»è¦ç”¨äºŽï¼š

- å›¾åƒå¤„ç†ï¼ˆæ»¤æ³¢ã€è¾¹ç¼˜æ£€æµ‹ã€ç›´æ–¹å›¾å‡è¡¡åŒ–ç­‰ï¼‰
- è®¡ç®—æœºè§†è§‰ï¼ˆç›®æ ‡æ£€æµ‹ã€ç‰©ä½“è·Ÿè¸ªã€äººè„¸è¯†åˆ«ç­‰ï¼‰
- è§†é¢‘å¤„ç†ï¼ˆè§†é¢‘è¯»å–ã€å†™å…¥ã€å¸§å¤„ç†ç­‰ï¼‰
- pip install opencv-python



### æ•°æ®å¢žå¼ºï¼š**Albumentations vs OpenCV**

- `Albumentations` æ˜¯ä¸€ä¸ª **é«˜æ•ˆ** çš„ **æ•°æ®å¢žå¼ºåº“**ï¼Œç”¨äºŽå¯¹å›¾åƒå’Œç›®æ ‡æ¡†ï¼ˆBounding Boxesï¼‰è¿›è¡Œå˜æ¢ã€‚
- ä½¿ç”¨ **Albumentations** è¿›è¡Œ **æ•°æ®å¢žå¼ºï¼ˆData Augmentationï¼‰**ï¼Œä¸»è¦ç”¨äºŽ **è®¡ç®—æœºè§†è§‰ä»»åŠ¡**ï¼Œç‰¹åˆ«æ˜¯**ç›®æ ‡æ£€æµ‹ï¼ˆObject Detectionï¼‰å’Œåˆ†ç±»**ã€‚
- å¥½å¤„ï¼š
  - **æ›´å¿«**ï¼šæ¯” OpenCVã€PIL æ›´å¿«ï¼ˆC++ ä¼˜åŒ–ï¼‰ã€‚
  - **æ˜“ç”¨**ï¼šå‡ è¡Œä»£ç å³å¯å®žçŽ°å¤æ‚çš„æ•°æ®å¢žå¼ºã€‚
  - **æ”¯æŒç›®æ ‡æ£€æµ‹**ï¼šæ”¯æŒ `Pascal VOC`ã€`COCO`ã€`YOLO` æ ¼å¼çš„ç›®æ ‡æ¡†å˜æ¢ã€‚
  - **æ”¯æŒè¯­ä¹‰åˆ†å‰²**ï¼šå¯å¯¹ **Mask** è¿›è¡Œç›¸åŒå˜æ¢ã€‚



### **ðŸ’¡ ä»£ç ç¤ºä¾‹**

#### åŸºæœ¬æ•°æ®å¢žå¼ºæ–¹æ³•ï¼š1. éšæœºç¿»è½¬ï¼ˆæ°´å¹³/åž‚ç›´ï¼‰

```Python
import cv2
import numpy as np

image = cv2.imread("image.jpg")

# æ°´å¹³ç¿»è½¬
h_flip = cv2.flip(image, 1)

# åž‚ç›´ç¿»è½¬
v_flip = cv2.flip(image, 0)

cv2.imshow("Horizontal Flip", h_flip)
cv2.imshow("Vertical Flip", v_flip)
cv2.waitKey(0)
cv2.destroyAllWindows()

```



#### **ðŸ“Œ 2. 2D ç›®æ ‡æ£€æµ‹ä¸­çš„æ•°æ®å¢žå¼º**

```python
import albumentations as A
import cv2

transform = A.Compose([
    A.HorizontalFlip(p=0.5),
    A.RandomBrightnessContrast(p=0.2),
    A.Rotate(limit=15, p=0.5)
], bbox_params=A.BboxParams(format="pascal_voc"))

image = cv2.imread("image.jpg")
bboxes = [[50, 60, 200, 300]]  # (xmin, ymin, xmax, ymax)

transformed = transform(image=image, bboxes=bboxes)

```

åœ¨ OpenCV (`cv2`) ä¸­ï¼Œå¸¸ç”¨äºŽ **æ•°æ®å¢žå¼ºï¼ˆData Augmentationï¼‰** çš„å‡½æ•°å¦‚ä¸‹

| æ–¹æ³•         | OpenCV ä»£ç                  | é€‚ç”¨äºŽ          |
| ------------ | --------------------------- | --------------- |
| **ç¿»è½¬**     | `cv2.flip()`                | åˆ†ç±» / ç›®æ ‡æ£€æµ‹ |
| **æ—‹è½¬**     | `cv2.getRotationMatrix2D()` | åˆ†ç±» / OCR      |
| **ç¼©æ”¾**     | `cv2.resize()`              | åˆ†ç±» / ç›®æ ‡æ£€æµ‹ |
| **è£å‰ª**     | `image[y:y+h, x:x+w]`       | ç›®æ ‡æ£€æµ‹        |
| **äº®åº¦è°ƒæ•´** | `cv2.convertScaleAbs()`     | åˆ†ç±» / ç›®æ ‡æ£€æµ‹ |
| **å™ªå£°**     | `np.random.normal()`        | ä½Žå…‰çŽ¯å¢ƒå¢žå¼º    |
| **é¢œè‰²å˜æ¢** | `cv2.COLOR_BGR2HSV`         | ç›®æ ‡æ£€æµ‹        |



## è¡¥å……ï¼š 3Dç›®æ ‡æ£€æµ‹

3D ç›®æ ‡æ£€æµ‹ä¸»è¦åŸºäºŽ **ç‚¹äº‘ï¼ˆPoint Cloudï¼‰** æˆ– **RGB-D å›¾åƒ**ï¼Œé€šå¸¸ä½¿ç”¨ **æ¿€å…‰é›·è¾¾ï¼ˆLiDARï¼‰ã€RGB-D æ‘„åƒå¤´ã€æ¯«ç±³æ³¢é›·è¾¾** ç­‰ä¼ æ„Ÿå™¨ã€‚æ•°æ®å¢žå¼ºéœ€è¦åŒæ—¶ä½œç”¨äºŽ **3D ç‚¹äº‘ï¼ˆPoint Cloudï¼‰** å’Œ **3D è¾¹ç•Œæ¡†ï¼ˆBounding Boxï¼‰**ã€‚

### **1ã€3D ç›®æ ‡æ£€æµ‹å¢žå¼ºæ–¹æ³•**

| æ–¹æ³•                           | ä½œç”¨               | é€‚ç”¨åœºæ™¯         |
| ------------------------------ | ------------------ | ---------------- |
| **ç‚¹äº‘ç¿»è½¬ï¼ˆFlipï¼‰**           | åè½¬ X/Y/Z è½´      | é€‚åº”å¯¹ç§°æ€§åœºæ™¯   |
| **ç‚¹äº‘æ—‹è½¬ï¼ˆRotationï¼‰**       | æ—‹è½¬ç‚¹äº‘ & 3D BBox | é€‚åº”å¤šè§’åº¦ç›®æ ‡   |
| **ç‚¹äº‘ç¼©æ”¾ï¼ˆScalingï¼‰**        | æ”¾å¤§/ç¼©å°ç‚¹äº‘      | é€‚åº”ä¸åŒå°ºå¯¸ç›®æ ‡ |
| **ç‚¹äº‘æŠ–åŠ¨ï¼ˆJitteringï¼‰**      | æ·»åŠ å°‘é‡éšæœºå™ªå£°   | å¢žå¼ºé²æ£’æ€§       |
| **ç‚¹äº‘è£å‰ªï¼ˆCroppingï¼‰**       | é€‰å–å±€éƒ¨ç‚¹äº‘       | é€‚åº”å±€éƒ¨ä¿¡æ¯     |
| **é«˜æ–¯æ‰°åŠ¨ï¼ˆGaussian Noiseï¼‰** | æ¨¡æ‹Ÿä¼ æ„Ÿå™¨è¯¯å·®     | ä½Žè´¨é‡ç‚¹äº‘é€‚åº”æ€§ |
| **Dropoutï¼ˆéšæœºä¸¢å¼ƒç‚¹ï¼‰**      | ä½¿ç‚¹äº‘ç¨€ç–åŒ–       | é€‚åº”ä½Žè´¨é‡æ•°æ®   |
| **MixUp & CutMix 3D**          | ç»„åˆå¤šä¸ªç‚¹äº‘       | é€‚åº”ä¸åŒç±»åˆ«     |
| **èƒŒæ™¯æ›¿æ¢**                   | æ›¿æ¢ç‚¹äº‘èƒŒæ™¯       | æ¨¡æ‹ŸçœŸå®žçŽ¯å¢ƒ     |

### **ðŸ“Œ æŽ¨èå·¥å…·**

1. **Open3D**ï¼ˆå¸¸ç”¨äºŽç‚¹äº‘å¤„ç†ï¼‰

2. **mmdetection3d**ï¼ˆæ”¯æŒå¤šç§å¢žå¼ºç­–ç•¥ï¼‰

3. **PyTorch3D**ï¼ˆé«˜çº§ 3D å˜æ¢ï¼‰

4. **PointAugmentï¼ˆæ·±åº¦å­¦ä¹ è‡ªé€‚åº”å¢žå¼ºï¼‰**

5. **SECOND & OpenPCDetï¼ˆLiDAR 3D æ£€æµ‹ï¼‰**

   

âœ… 3D: Open3D æ—‹è½¬

```Python
import open3d as o3d
import numpy as np

# è¯»å–ç‚¹äº‘
pcd = o3d.io.read_point_cloud("point_cloud.pcd")

# æ—‹è½¬ç‚¹äº‘
R = pcd.get_rotation_matrix_from_xyz((0, np.pi/4, 0))  # æ—‹è½¬45åº¦
pcd.rotate(R, center=(0, 0, 0))

o3d.visualization.draw_geometries([pcd])

```



### **2ã€æœºå™¨äººè§†è§‰ï¼ˆRobotic Perceptionï¼‰**

æœºå™¨äººé€šå¸¸ä½¿ç”¨ **å¤šæ¨¡æ€æ•°æ®ï¼ˆRGB + æ·±åº¦ + ç‚¹äº‘ï¼‰**ï¼Œæ‰€ä»¥æ•°æ®å¢žå¼ºé€šå¸¸éœ€è¦**åŒæ­¥**ä½œç”¨äºŽä¸åŒæ¨¡æ€æ•°æ®ã€‚

### **ðŸ“Œ å¸¸è§å¢žå¼ºæ–¹æ³•**

- **åŒæ­¥å¢žå¼ºï¼ˆRGB + ç‚¹äº‘ï¼‰**ï¼ˆä¿è¯ç›¸æœºå’Œ LiDAR ä¼ æ„Ÿå™¨æ•°æ®ä¸€è‡´ï¼‰
- **éšæœºé®æŒ¡ï¼ˆOcclusion Augmentationï¼‰**ï¼ˆæ¨¡æ‹Ÿé®æŒ¡çŽ¯å¢ƒï¼‰
- **çŽ¯å¢ƒæ¨¡æ‹Ÿï¼ˆDomain Adaptationï¼‰**ï¼ˆå®¤å†…/å®¤å¤–ä¸åŒå…‰ç…§ï¼‰
- **ä¼ æ„Ÿå™¨å™ªå£°æ¨¡æ‹Ÿï¼ˆSensor Noise Simulationï¼‰**ï¼ˆæ¿€å…‰é›·è¾¾ç‚¹äº‘è¯¯å·®ã€ç›¸æœºå…‰ç…§å˜åŒ–ï¼‰

### **ðŸ“Œ æŽ¨èå·¥å…·**

1. **ROS & Gazebo**ï¼ˆæœºå™¨äººä»¿çœŸçŽ¯å¢ƒï¼‰
2. **NVIDIA Isaac Sim**ï¼ˆçœŸå®žç‰©ç†ä»¿çœŸï¼‰



âœ… æœºå™¨äººç›®æ ‡æ£€æµ‹: OpenCV + æ·±åº¦å›¾

```Python
import cv2
import numpy as np

depth_image = cv2.imread("depth.png", cv2.IMREAD_UNCHANGED)

# å½’ä¸€åŒ–æ·±åº¦å›¾
depth_normalized = cv2.normalize(depth_image, None, 0, 255, cv2.NORM_MINMAX)

# é¢œè‰²æ˜ å°„
depth_colormap = cv2.applyColorMap(depth_normalized.astype(np.uint8), cv2.COLORMAP_JET)

cv2.imshow("Depth Image", depth_colormap)
cv2.waitKey(0)
cv2.destroyAllWindows()

```



## **æ€»ç»“**

| ç›®æ ‡            | å¸¸ç”¨å¢žå¼ºæ–¹æ³•                    | æŽ¨èå·¥å…·                         |
| --------------- | ------------------------------- | -------------------------------- |
| **2D ç›®æ ‡æ£€æµ‹** | ç¿»è½¬ã€æ—‹è½¬ã€ç¼©æ”¾ã€Mosaicã€MixUp | OpenCV, Albumentations, YOLO     |
| **3D ç›®æ ‡æ£€æµ‹** | ç‚¹äº‘æ—‹è½¬ã€ç¼©æ”¾ã€å™ªå£°ã€éšæœºé®æŒ¡  | Open3D, PyTorch3D, mmdetection3d |
| **æœºå™¨äººè§†è§‰**  | RGB+æ·±åº¦åŒæ­¥å¢žå¼ºã€çŽ¯å¢ƒæ¨¡æ‹Ÿ      | ROS, Isaac Sim, AirSim           |

- **Albumentations**ï¼ˆé€‚åˆ 2Dï¼‰
- **Open3D & PyTorch3D**ï¼ˆé€‚åˆ 3Dï¼‰
- **ROS/Gazebo**ï¼ˆé€‚åˆæœºå™¨äººï¼‰

ðŸ’¡ **å¦‚æžœä½ çš„ä»»åŠ¡æ˜¯ 2D ç›®æ ‡æ£€æµ‹ï¼ŒæŽ¨è** `Albumentations`
ðŸ’¡ **å¦‚æžœæ˜¯ 3D ç‚¹äº‘ï¼ŒæŽ¨è** `Open3D`
ðŸ’¡ **å¦‚æžœæ˜¯æœºå™¨äººä»¿çœŸï¼ŒæŽ¨è** `ROS & Gazebo`



