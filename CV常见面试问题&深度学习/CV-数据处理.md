# Computer Visioné«˜é¢‘é¢è¯•é¢˜ - å¸¸è§æ•°æ®å¤„ç†å’Œç‰¹å¾å·¥ç¨‹æ–¹æ³•



## **1. å¸¸ç”¨çš„æ•°æ®æ¸…æ´—æ–¹æ³•**

**é¢è¯•è€ƒå¯Ÿç‚¹ï¼š**

- **æ•°æ®æ¸…ç†åœ¨æœºå™¨å­¦ä¹ å’Œè®¡ç®—æœºè§†è§‰ä»»åŠ¡ä¸­çš„é‡è¦æ€§ã€‚**
- **å¦‚ä½•å¤„ç†ç¼ºå¤±å€¼ï¼Ÿ**
- **å¦‚ä½•å¤„ç†å¼‚å¸¸å€¼ï¼Ÿ**
- **èƒ½å¦ä½¿ç”¨åˆé€‚çš„ Python ä»£ç å®ç°è¿™äº›æ–¹æ³•ï¼Ÿ**

------

### **1.1 å¤„ç†ç¼ºå¤±å€¼çš„æ–¹æ³•**

| **æ–¹æ³•**                                  | **æ ¸å¿ƒæ€è·¯**             | **é€‚ç”¨åœºæ™¯**                     |
| ----------------------------------------- | ------------------------ | -------------------------------- |
| **åˆ é™¤ç¼ºå¤±å€¼**                            | ç›´æ¥åˆ é™¤åŒ…å«ç¼ºå¤±å€¼çš„æ ·æœ¬ | å½“ç¼ºå¤±å€¼è¾ƒå°‘ä¸”æ•°æ®é‡å……è¶³æ—¶       |
| **å‡å€¼å¡«è¡¥æ³•**                            | ç”¨è¯¥åˆ—çš„å‡å€¼å¡«è¡¥ç¼ºå¤±å€¼   | é€‚ç”¨äºæ•°æ®æœä»æ­£æ€åˆ†å¸ƒ           |
| **ä¸­ä½æ•°å¡«è¡¥æ³•**                          | ç”¨è¯¥åˆ—çš„ä¸­ä½æ•°å¡«è¡¥ç¼ºå¤±å€¼ | é€‚ç”¨äºæ•°æ®å—æç«¯å€¼å½±å“è¾ƒå¤§çš„æƒ…å†µ |
| **ä¼—æ•°å¡«è¡¥æ³•**                            | ç”¨è¯¥åˆ—çš„ä¼—æ•°å¡«è¡¥ç¼ºå¤±å€¼   | é€‚ç”¨äºåˆ†ç±»å˜é‡                   |
| **çƒ­å¡å¡«è¡¥æ³•ï¼ˆKNN æˆ– æœºå™¨å­¦ä¹ æ¨¡å‹å¡«å……ï¼‰** | é€šè¿‡ç›¸ä¼¼æ•°æ®å¡«å……ç¼ºå¤±å€¼   | é€‚ç”¨äºé«˜ç»´æ•°æ®æˆ–ç»“æ„åŒ–æ•°æ®       |

------

### **1.2 å¤„ç†å¼‚å¸¸å€¼çš„æ–¹æ³•**

| **æ–¹æ³•**              | **æ ¸å¿ƒæ€è·¯**                            | **é€‚ç”¨åœºæ™¯**                             |
| --------------------- | --------------------------------------- | ---------------------------------------- |
| **ç»Ÿè®¡åˆ†ææ³•**        | è®¡ç®—æœ€å¤§æœ€å°å€¼ï¼Œåˆ¤æ–­æ˜¯å¦åˆç†            | é€‚ç”¨äºæ•°æ®èŒƒå›´å›ºå®šçš„æƒ…å†µï¼ˆå¦‚å¹´é¾„ã€æ¸©åº¦ï¼‰ |
| **3Ïƒ åŸåˆ™**           | è®¡ç®—å‡å€¼ Â± 3 * æ ‡å‡†å·®èŒƒå›´å¤–çš„å€¼ä¸ºå¼‚å¸¸å€¼ | é€‚ç”¨äºæ­£æ€åˆ†å¸ƒæ•°æ®                       |
| **ç®±å‹å›¾ï¼ˆIQRï¼‰åˆ†æ** | è®¡ç®—å››åˆ†ä½è·ï¼ˆIQRï¼‰ç­›é€‰å¼‚å¸¸å€¼           | é€‚ç”¨äºæ•°æ®éæ­£æ€åˆ†å¸ƒçš„æƒ…å†µ               |
| **åŸºäºæ¨¡å‹æ£€æµ‹**      | è®­ç»ƒåˆ†ç±»/å›å½’æ¨¡å‹è¯†åˆ«å¼‚å¸¸å€¼             | é€‚ç”¨äºå¼‚å¸¸æ¨¡å¼è¾ƒæ˜æ˜¾çš„æ•°æ®               |
| **åŸºäºè·ç¦»æ£€æµ‹**      | è®¡ç®—æ•°æ®ç‚¹ä¹‹é—´çš„æ¬§å‡ é‡Œå¾—è·ç¦»            | é€‚ç”¨äºå¯†åº¦å‡åŒ€çš„èšç±»æ•°æ®                 |
| **åŸºäºå¯†åº¦æ£€æµ‹**      | DBSCANã€LOF è®¡ç®—å¯†åº¦å·®å¼‚                | é€‚ç”¨äºæ•°æ®å¯†åº¦å˜åŒ–è¾ƒå¤§çš„æƒ…å†µ             |

------

### **ğŸ’¡ ä»£ç ç¤ºä¾‹**

#### **ğŸ“Œ 1. ç¼ºå¤±å€¼å¤„ç†**

```python
import pandas as pd
from sklearn.impute import SimpleImputer

# åˆ›å»ºç¤ºä¾‹æ•°æ®
data = {
    "A": [1, 2, None, 4, 5],
    "B": [None, 2, 3, None, 5],
    "C": [10, 15, 20, 25, None]
}
df = pd.DataFrame(data)

# 1. åˆ é™¤ç¼ºå¤±å€¼
df_dropped = df.dropna()

# 2. å‡å€¼å¡«è¡¥
imputer_mean = SimpleImputer(strategy="mean")
df_filled = pd.DataFrame(imputer_mean.fit_transform(df), columns=df.columns)

print("åŸå§‹æ•°æ®ï¼š\n", df)
print("åˆ é™¤ç¼ºå¤±å€¼åçš„æ•°æ®ï¼š\n", df_dropped)
print("å¡«å……ç¼ºå¤±å€¼åçš„æ•°æ®ï¼š\n", df_filled)
```



#### **ğŸ“Œ 2. å¼‚å¸¸å€¼å¤„ç†ï¼ˆç®±å‹å›¾/IQR æ–¹æ³•ï¼‰**

```python
import numpy as np

# è®¡ç®— IQR
Q1 = df["C"].quantile(0.25)
Q3 = df["C"].quantile(0.75)
IQR = Q3 - Q1

# ç¡®å®šå¼‚å¸¸å€¼çš„èŒƒå›´
lower_bound = Q1 - 1.5 * IQR
upper_bound = Q3 + 1.5 * IQR

# è¿‡æ»¤å¼‚å¸¸å€¼
df_no_outliers = df[(df["C"] >= lower_bound) & (df["C"] <= upper_bound)]
print("å»é™¤å¼‚å¸¸å€¼åçš„æ•°æ®ï¼š\n", df_no_outliers)
```

------

## **ğŸ¯ æ€»ç»“**

### **ğŸ“Œ æ•°æ®æ¸…æ´—**

- ç¼ºå¤±å€¼å¤„ç†ï¼š

  - **åˆ é™¤ç¼ºå¤±å€¼**ï¼šé€‚ç”¨äºæ•°æ®é‡å¤§ä¸”ç¼ºå¤±æ¯”ä¾‹ä½çš„æƒ…å†µã€‚
  - **å‡å€¼/ä¸­ä½æ•°å¡«è¡¥**ï¼šé€‚ç”¨äºæ•°å€¼å‹æ•°æ®ã€‚
  - **æœºå™¨å­¦ä¹ å¡«è¡¥**ï¼šé€‚ç”¨äºé«˜ç»´æ•°æ®ã€‚

- å¼‚å¸¸å€¼å¤„ç†ï¼š

  - **3Ïƒ åŸåˆ™**ï¼šé€‚ç”¨äºæ­£æ€åˆ†å¸ƒæ•°æ®ã€‚
  - **IQR ç®±å‹å›¾**ï¼šé€‚ç”¨äºéæ­£æ€åˆ†å¸ƒæ•°æ®ã€‚
  - **åŸºäºæ¨¡å‹/èšç±»çš„æ–¹æ³•**ï¼šé€‚ç”¨äºå¤æ‚æ•°æ®ã€‚

  

## **2. ç›®æ ‡æ£€æµ‹ä¸­çš„æ•°æ®å¢å¼ºæ–¹æ³•**

**é¢è¯•è€ƒå¯Ÿç‚¹ï¼š**

- **æ•°æ®å¢å¼ºå¯¹äºç›®æ ‡æ£€æµ‹ä»»åŠ¡çš„å¿…è¦æ€§ã€‚**
- **èƒ½å¦æ­£ç¡®å¤„ç† Bounding Box çš„å˜åŒ–ï¼Ÿ**
- **å¦‚ä½•ä½¿ç”¨ Python ä»£ç å®ç°æ•°æ®å¢å¼ºï¼Ÿ**

------

### **2.1 ç›®æ ‡æ£€æµ‹çš„å¸¸è§æ•°æ®å¢å¼ºæ–¹æ³•**

| **æ–¹æ³•**                                 | **å½±å“**           | **Bounding Box å¤„ç†**         |
| ---------------------------------------- | ------------------ | ----------------------------- |
| **è£å‰ª (Crop)**                          | æ”¾å¤§æˆ–ç¼©å°ç›®æ ‡åŒºåŸŸ | éœ€è¦é‡æ–°è®¡ç®—ç›®æ ‡æ¡†            |
| **å¹³ç§» (Translation)**                   | ä½¿ç›®æ ‡åç§»ä¸€å®šåƒç´  | ç›®æ ‡æ¡†éšå›¾åƒç§»åŠ¨              |
| **æ—‹è½¬ (Rotation)**                      | ç›®æ ‡å€¾æ–œ           | éœ€æ—‹è½¬ç›®æ ‡æ¡†                  |
| **é•œåƒ (Flip - Horizontal/Vertical)**    | å·¦å³ç¿»è½¬ç›®æ ‡       | æ°´å¹³ç¿»è½¬æ—¶éœ€è°ƒæ•´ç›®æ ‡æ¡† X åæ ‡ |
| **é¢œè‰²å˜åŒ– (Brightness, Contrast, Hue)** | å½±å“è§†è§‰æ„ŸçŸ¥       | ä¸å½±å“ç›®æ ‡æ¡†                  |
| **æ·»åŠ å™ªå£° (Gaussian Noise)**            | ä½¿æ¨¡å‹æ›´é²æ£’       | ä¸å½±å“ç›®æ ‡æ¡†                  |

------

### **OpenCV ä»‹ç»**

OpenCV æ˜¯ä¸€ä¸ªç”¨äº **è®¡ç®—æœºè§†è§‰ï¼ˆComputer Visionï¼‰å’Œå›¾åƒå¤„ç†** çš„å¼€æºåº“ï¼Œæ”¯æŒå¤šç§ç¼–ç¨‹è¯­è¨€ï¼ˆPythonã€C++ã€Java ç­‰ï¼‰ï¼Œä¸»è¦ç”¨äºï¼š

- å›¾åƒå¤„ç†ï¼ˆæ»¤æ³¢ã€è¾¹ç¼˜æ£€æµ‹ã€ç›´æ–¹å›¾å‡è¡¡åŒ–ç­‰ï¼‰
- è®¡ç®—æœºè§†è§‰ï¼ˆç›®æ ‡æ£€æµ‹ã€ç‰©ä½“è·Ÿè¸ªã€äººè„¸è¯†åˆ«ç­‰ï¼‰
- è§†é¢‘å¤„ç†ï¼ˆè§†é¢‘è¯»å–ã€å†™å…¥ã€å¸§å¤„ç†ç­‰ï¼‰
- pip install opencv-python



### æ•°æ®å¢å¼ºï¼š**Albumentations vs OpenCV**

- `Albumentations` æ˜¯ä¸€ä¸ª **é«˜æ•ˆ** çš„ **æ•°æ®å¢å¼ºåº“**ï¼Œç”¨äºå¯¹å›¾åƒå’Œç›®æ ‡æ¡†ï¼ˆBounding Boxesï¼‰è¿›è¡Œå˜æ¢ã€‚
- ä½¿ç”¨ **Albumentations** è¿›è¡Œ **æ•°æ®å¢å¼ºï¼ˆData Augmentationï¼‰**ï¼Œä¸»è¦ç”¨äº **è®¡ç®—æœºè§†è§‰ä»»åŠ¡**ï¼Œç‰¹åˆ«æ˜¯**ç›®æ ‡æ£€æµ‹ï¼ˆObject Detectionï¼‰å’Œåˆ†ç±»**ã€‚
- å¥½å¤„ï¼š
  - **æ›´å¿«**ï¼šæ¯” OpenCVã€PIL æ›´å¿«ï¼ˆC++ ä¼˜åŒ–ï¼‰ã€‚
  - **æ˜“ç”¨**ï¼šå‡ è¡Œä»£ç å³å¯å®ç°å¤æ‚çš„æ•°æ®å¢å¼ºã€‚
  - **æ”¯æŒç›®æ ‡æ£€æµ‹**ï¼šæ”¯æŒ `Pascal VOC`ã€`COCO`ã€`YOLO` æ ¼å¼çš„ç›®æ ‡æ¡†å˜æ¢ã€‚
  - **æ”¯æŒè¯­ä¹‰åˆ†å‰²**ï¼šå¯å¯¹ **Mask** è¿›è¡Œç›¸åŒå˜æ¢ã€‚



### **ğŸ’¡ ä»£ç ç¤ºä¾‹**

#### åŸºæœ¬æ•°æ®å¢å¼ºæ–¹æ³•ï¼š1. éšæœºç¿»è½¬ï¼ˆæ°´å¹³/å‚ç›´ï¼‰

```Python
import cv2
import numpy as np

image = cv2.imread("image.jpg")

# æ°´å¹³ç¿»è½¬
h_flip = cv2.flip(image, 1)

# å‚ç›´ç¿»è½¬
v_flip = cv2.flip(image, 0)

cv2.imshow("Horizontal Flip", h_flip)
cv2.imshow("Vertical Flip", v_flip)
cv2.waitKey(0)
cv2.destroyAllWindows()

```



#### **ğŸ“Œ 2. 2D ç›®æ ‡æ£€æµ‹ä¸­çš„æ•°æ®å¢å¼º**

```python
import albumentations as A
import cv2

transform = A.Compose([
    A.HorizontalFlip(p=0.5),
    A.RandomBrightnessContrast(p=0.2),
    A.Rotate(limit=15, p=0.5)
], bbox_params=A.BboxParams(format="pascal_voc"))

image = cv2.imread("image.jpg")
bboxes = [[50, 60, 200, 300]]  # (xmin, ymin, xmax, ymax)

transformed = transform(image=image, bboxes=bboxes)

```

åœ¨ OpenCV (`cv2`) ä¸­ï¼Œå¸¸ç”¨äº **æ•°æ®å¢å¼ºï¼ˆData Augmentationï¼‰** çš„å‡½æ•°å¦‚ä¸‹

| æ–¹æ³•         | OpenCV ä»£ç                  | é€‚ç”¨äº          |
| ------------ | --------------------------- | --------------- |
| **ç¿»è½¬**     | `cv2.flip()`                | åˆ†ç±» / ç›®æ ‡æ£€æµ‹ |
| **æ—‹è½¬**     | `cv2.getRotationMatrix2D()` | åˆ†ç±» / OCR      |
| **ç¼©æ”¾**     | `cv2.resize()`              | åˆ†ç±» / ç›®æ ‡æ£€æµ‹ |
| **è£å‰ª**     | `image[y:y+h, x:x+w]`       | ç›®æ ‡æ£€æµ‹        |
| **äº®åº¦è°ƒæ•´** | `cv2.convertScaleAbs()`     | åˆ†ç±» / ç›®æ ‡æ£€æµ‹ |
| **å™ªå£°**     | `np.random.normal()`        | ä½å…‰ç¯å¢ƒå¢å¼º    |
| **é¢œè‰²å˜æ¢** | `cv2.COLOR_BGR2HSV`         | ç›®æ ‡æ£€æµ‹        |



## è¡¥å……ï¼š 3Dç›®æ ‡æ£€æµ‹

3D ç›®æ ‡æ£€æµ‹ä¸»è¦åŸºäº **ç‚¹äº‘ï¼ˆPoint Cloudï¼‰** æˆ– **RGB-D å›¾åƒ**ï¼Œé€šå¸¸ä½¿ç”¨ **æ¿€å…‰é›·è¾¾ï¼ˆLiDARï¼‰ã€RGB-D æ‘„åƒå¤´ã€æ¯«ç±³æ³¢é›·è¾¾** ç­‰ä¼ æ„Ÿå™¨ã€‚æ•°æ®å¢å¼ºéœ€è¦åŒæ—¶ä½œç”¨äº **3D ç‚¹äº‘ï¼ˆPoint Cloudï¼‰** å’Œ **3D è¾¹ç•Œæ¡†ï¼ˆBounding Boxï¼‰**ã€‚

### **1ã€3D ç›®æ ‡æ£€æµ‹å¢å¼ºæ–¹æ³•**

| æ–¹æ³•                           | ä½œç”¨               | é€‚ç”¨åœºæ™¯         |
| ------------------------------ | ------------------ | ---------------- |
| **ç‚¹äº‘ç¿»è½¬ï¼ˆFlipï¼‰**           | åè½¬ X/Y/Z è½´      | é€‚åº”å¯¹ç§°æ€§åœºæ™¯   |
| **ç‚¹äº‘æ—‹è½¬ï¼ˆRotationï¼‰**       | æ—‹è½¬ç‚¹äº‘ & 3D BBox | é€‚åº”å¤šè§’åº¦ç›®æ ‡   |
| **ç‚¹äº‘ç¼©æ”¾ï¼ˆScalingï¼‰**        | æ”¾å¤§/ç¼©å°ç‚¹äº‘      | é€‚åº”ä¸åŒå°ºå¯¸ç›®æ ‡ |
| **ç‚¹äº‘æŠ–åŠ¨ï¼ˆJitteringï¼‰**      | æ·»åŠ å°‘é‡éšæœºå™ªå£°   | å¢å¼ºé²æ£’æ€§       |
| **ç‚¹äº‘è£å‰ªï¼ˆCroppingï¼‰**       | é€‰å–å±€éƒ¨ç‚¹äº‘       | é€‚åº”å±€éƒ¨ä¿¡æ¯     |
| **é«˜æ–¯æ‰°åŠ¨ï¼ˆGaussian Noiseï¼‰** | æ¨¡æ‹Ÿä¼ æ„Ÿå™¨è¯¯å·®     | ä½è´¨é‡ç‚¹äº‘é€‚åº”æ€§ |
| **Dropoutï¼ˆéšæœºä¸¢å¼ƒç‚¹ï¼‰**      | ä½¿ç‚¹äº‘ç¨€ç–åŒ–       | é€‚åº”ä½è´¨é‡æ•°æ®   |
| **MixUp & CutMix 3D**          | ç»„åˆå¤šä¸ªç‚¹äº‘       | é€‚åº”ä¸åŒç±»åˆ«     |
| **èƒŒæ™¯æ›¿æ¢**                   | æ›¿æ¢ç‚¹äº‘èƒŒæ™¯       | æ¨¡æ‹ŸçœŸå®ç¯å¢ƒ     |

### **ğŸ“Œ æ¨èå·¥å…·**

1. **Open3D**ï¼ˆå¸¸ç”¨äºç‚¹äº‘å¤„ç†ï¼‰

2. **mmdetection3d**ï¼ˆæ”¯æŒå¤šç§å¢å¼ºç­–ç•¥ï¼‰

3. **PyTorch3D**ï¼ˆé«˜çº§ 3D å˜æ¢ï¼‰

4. **PointAugmentï¼ˆæ·±åº¦å­¦ä¹ è‡ªé€‚åº”å¢å¼ºï¼‰**

5. **SECOND & OpenPCDetï¼ˆLiDAR 3D æ£€æµ‹ï¼‰**

   

âœ… 3D: Open3D æ—‹è½¬

```Python
import open3d as o3d
import numpy as np

# è¯»å–ç‚¹äº‘
pcd = o3d.io.read_point_cloud("point_cloud.pcd")

# æ—‹è½¬ç‚¹äº‘
R = pcd.get_rotation_matrix_from_xyz((0, np.pi/4, 0))  # æ—‹è½¬45åº¦
pcd.rotate(R, center=(0, 0, 0))

o3d.visualization.draw_geometries([pcd])

```



### **2ã€æœºå™¨äººè§†è§‰ï¼ˆRobotic Perceptionï¼‰**

æœºå™¨äººé€šå¸¸ä½¿ç”¨ **å¤šæ¨¡æ€æ•°æ®ï¼ˆRGB + æ·±åº¦ + ç‚¹äº‘ï¼‰**ï¼Œæ‰€ä»¥æ•°æ®å¢å¼ºé€šå¸¸éœ€è¦**åŒæ­¥**ä½œç”¨äºä¸åŒæ¨¡æ€æ•°æ®ã€‚

### **ğŸ“Œ å¸¸è§å¢å¼ºæ–¹æ³•**

- **åŒæ­¥å¢å¼ºï¼ˆRGB + ç‚¹äº‘ï¼‰**ï¼ˆä¿è¯ç›¸æœºå’Œ LiDAR ä¼ æ„Ÿå™¨æ•°æ®ä¸€è‡´ï¼‰
- **éšæœºé®æŒ¡ï¼ˆOcclusion Augmentationï¼‰**ï¼ˆæ¨¡æ‹Ÿé®æŒ¡ç¯å¢ƒï¼‰
- **ç¯å¢ƒæ¨¡æ‹Ÿï¼ˆDomain Adaptationï¼‰**ï¼ˆå®¤å†…/å®¤å¤–ä¸åŒå…‰ç…§ï¼‰
- **ä¼ æ„Ÿå™¨å™ªå£°æ¨¡æ‹Ÿï¼ˆSensor Noise Simulationï¼‰**ï¼ˆæ¿€å…‰é›·è¾¾ç‚¹äº‘è¯¯å·®ã€ç›¸æœºå…‰ç…§å˜åŒ–ï¼‰

### **ğŸ“Œ æ¨èå·¥å…·**

1. **ROS & Gazebo**ï¼ˆæœºå™¨äººä»¿çœŸç¯å¢ƒï¼‰
2. **NVIDIA Isaac Sim**ï¼ˆçœŸå®ç‰©ç†ä»¿çœŸï¼‰



âœ… æœºå™¨äººç›®æ ‡æ£€æµ‹: OpenCV + æ·±åº¦å›¾

```Python
import cv2
import numpy as np

depth_image = cv2.imread("depth.png", cv2.IMREAD_UNCHANGED)

# å½’ä¸€åŒ–æ·±åº¦å›¾
depth_normalized = cv2.normalize(depth_image, None, 0, 255, cv2.NORM_MINMAX)

# é¢œè‰²æ˜ å°„
depth_colormap = cv2.applyColorMap(depth_normalized.astype(np.uint8), cv2.COLORMAP_JET)

cv2.imshow("Depth Image", depth_colormap)
cv2.waitKey(0)
cv2.destroyAllWindows()

```



## **æ€»ç»“**

| ç›®æ ‡            | å¸¸ç”¨å¢å¼ºæ–¹æ³•                    | æ¨èå·¥å…·                         |
| --------------- | ------------------------------- | -------------------------------- |
| **2D ç›®æ ‡æ£€æµ‹** | ç¿»è½¬ã€æ—‹è½¬ã€ç¼©æ”¾ã€Mosaicã€MixUp | OpenCV, Albumentations, YOLO     |
| **3D ç›®æ ‡æ£€æµ‹** | ç‚¹äº‘æ—‹è½¬ã€ç¼©æ”¾ã€å™ªå£°ã€éšæœºé®æŒ¡  | Open3D, PyTorch3D, mmdetection3d |
| **æœºå™¨äººè§†è§‰**  | RGB+æ·±åº¦åŒæ­¥å¢å¼ºã€ç¯å¢ƒæ¨¡æ‹Ÿ      | ROS, Isaac Sim, AirSim           |

- **Albumentations**ï¼ˆé€‚åˆ 2Dï¼‰
- **Open3D & PyTorch3D**ï¼ˆé€‚åˆ 3Dï¼‰
- **ROS/Gazebo**ï¼ˆé€‚åˆæœºå™¨äººï¼‰

ğŸ’¡ **å¦‚æœä½ çš„ä»»åŠ¡æ˜¯ 2D ç›®æ ‡æ£€æµ‹ï¼Œæ¨è** `Albumentations`
ğŸ’¡ **å¦‚æœæ˜¯ 3D ç‚¹äº‘ï¼Œæ¨è** `Open3D`
ğŸ’¡ **å¦‚æœæ˜¯æœºå™¨äººä»¿çœŸï¼Œæ¨è** `ROS & Gazebo`



## **3. ä¸ºä»€ä¹ˆè¦å¯¹ç‰¹å¾åšå½’ä¸€åŒ–ï¼Ÿå¸¸ç”¨çš„å½’ä¸€åŒ–æ–¹æ³•æœ‰å“ªäº›ï¼Ÿ**

### **é¢è¯•è€ƒå¯Ÿç‚¹ï¼š**

- **ç†è§£å½’ä¸€åŒ–çš„ä½œç”¨åŠå…¶å¯¹æ¨¡å‹è®­ç»ƒçš„å½±å“**
- **ä¸åŒå½’ä¸€åŒ–æ–¹æ³•çš„é€‚ç”¨åœºæ™¯**
- **å¦‚ä½•åœ¨å®é™…æ•°æ®å¤„ç†ä¸­åº”ç”¨å½’ä¸€åŒ–ï¼ˆä»£ç å®ç°ï¼‰**

------

### **3.1 ä¸ºä»€ä¹ˆè¦åšå½’ä¸€åŒ–ï¼Ÿ**

**å½’ä¸€åŒ–ï¼ˆNormalizationï¼‰** æ˜¯ä¸€ç§æ•°æ®é¢„å¤„ç†æ–¹æ³•ï¼Œç”¨äºè°ƒæ•´æ•°æ®çš„æ•°å€¼èŒƒå›´ï¼Œä½¿å…¶æ›´é€‚åˆæœºå™¨å­¦ä¹ æ¨¡å‹ã€‚ä¸»è¦ä½œç”¨åŒ…æ‹¬ï¼š

- **åŠ å¿«æ¨¡å‹è®­ç»ƒ**ï¼ˆå‡å°‘æ•°å€¼å·®å¼‚å¸¦æ¥çš„æ¢¯åº¦é—®é¢˜ï¼‰
- **æå‡æ¨¡å‹æ€§èƒ½**ï¼ˆé¿å…æŸäº›ç‰¹å¾å ä¸»å¯¼ï¼‰
- **å¢å¼ºæ•°å€¼ç¨³å®šæ€§**ï¼ˆé˜²æ­¢æ•°æ®æº¢å‡ºï¼‰

#### **1. æé«˜æ¢¯åº¦ä¸‹é™çš„æ”¶æ•›é€Ÿåº¦**

- å½’ä¸€åŒ–å¯ä»¥è®©æ‰€æœ‰ç‰¹å¾åœ¨åŒä¸€æ•°é‡çº§ä¸Šï¼Œä»è€Œ**é¿å…æŸäº›ç‰¹å¾å¯¹æ¢¯åº¦å½±å“è¿‡å¤§**ï¼Œæå‡è®­ç»ƒæ•ˆç‡ã€‚
- å¦‚æœç‰¹å¾å€¼å·®å¼‚å¾ˆå¤§ï¼ˆæ¯”å¦‚ä¸€ä¸ªç‰¹å¾æ˜¯ 0-1ï¼Œå¦ä¸€ä¸ªæ˜¯ 0-1000ï¼‰ï¼Œæœªå½’ä¸€åŒ–ä¼šå¯¼è‡´æƒé‡æ›´æ–°é€Ÿåº¦ä¸å‡è¡¡ã€‚

#### **2. <u>é¿å…æ•°å€¼è¿‡å¤§æˆ–è¿‡å°å½±å“æ¨¡å‹æ€§èƒ½</u>**

- **æ•°æ®åˆ†å¸ƒä¸å‡è¡¡** å¯èƒ½ä¼šå¯¼è‡´æŸäº›ç‰¹å¾åœ¨è®¡ç®—æ—¶å½±å“è¿‡å¤§æˆ–è¿‡å°ï¼Œå½±å“ç¥ç»ç½‘ç»œçš„è®­ç»ƒã€‚
- **ç¥ç»ç½‘ç»œä¸­ï¼Œæœªç»å½’ä¸€åŒ–çš„æ•°æ®å¯èƒ½å¯¼è‡´æ¢¯åº¦çˆ†ç‚¸æˆ–æ¢¯åº¦æ¶ˆå¤±**ã€‚

#### **3. è®©æ¨¡å‹å…·æœ‰æ›´å¥½çš„æ³›åŒ–èƒ½åŠ›**

- è®­ç»ƒé›†å’Œæµ‹è¯•é›†çš„æ•°æ®åˆ†å¸ƒä¸åŒä¼šå½±å“æ¨¡å‹æ³›åŒ–èƒ½åŠ›ï¼Œå½’ä¸€åŒ–å¯ä»¥å‡å°‘è¿™ç§å½±å“ã€‚

------

### **3.2 å¸¸ç”¨çš„å½’ä¸€åŒ–æ–¹æ³•**

| **æ–¹æ³•**                              | **è®¡ç®—å…¬å¼**                | **é€‚ç”¨åœºæ™¯**                                                 |
| ------------------------------------- | --------------------------- | ------------------------------------------------------------ |
| **Min-Max å½’ä¸€åŒ–ï¼ˆMin-Max Scalingï¼‰** | xâ€²=xâˆ’min(x)/max(x)âˆ’min(x)x' | é€‚ç”¨äº **æ•°æ®èŒƒå›´å·²çŸ¥**ï¼Œéœ€è¦å°†æ•°æ®æ˜ å°„åˆ° 0-1 ä¹‹é—´çš„æƒ…å†µï¼ˆå¦‚ CNN è¾“å…¥ï¼‰ã€‚ |
| **Z-score æ ‡å‡†åŒ–ï¼ˆæ ‡å‡†åˆ†æ•°ï¼‰**        | xâ€²=xâˆ’Î¼/Ïƒ                    | é€‚ç”¨äºæ•°æ®æœä» **æ­£æ€åˆ†å¸ƒ** çš„æƒ…å†µï¼Œå¦‚ Logistic Regressionã€SVMã€‚ |
| **Log å½’ä¸€åŒ–**                        | xâ€²=log(x+1)                 | é€‚ç”¨äºæ•°æ®åˆ†å¸ƒåæ–œï¼ˆä¾‹å¦‚æ”¶å…¥ã€ç‚¹å‡»æ¬¡æ•°ç­‰ï¼‰ã€‚                 |
| **Robust å½’ä¸€åŒ–ï¼ˆåŸºäºä¸­ä½æ•°å’Œ IQRï¼‰** | xâ€²=xâˆ’median(x)/IQR          | é€‚ç”¨äºæœ‰**æç«¯å€¼**çš„æ•°æ®ï¼Œå—å¼‚å¸¸å€¼å½±å“è¾ƒå°ã€‚                 |

------



### **3.3 ä»£ç ç¤ºä¾‹**

#### **ğŸ“Œ Min-Max å½’ä¸€åŒ–**

ğŸ“Œ **é€‚ç”¨åœºæ™¯**ï¼šå›¾åƒåƒç´ å½’ä¸€åŒ–ã€åŠ é€Ÿæ¢¯åº¦ä¸‹é™

```python
import numpy as np
from sklearn.preprocessing import MinMaxScaler

# ç¤ºä¾‹æ•°æ®
data = np.array([[100], [200], [300], [400], [500]])
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(data)

print("Min-Max å½’ä¸€åŒ–ç»“æœï¼š\n", scaled_data)
```



#### **ğŸ“Œ Z-score æ ‡å‡†åŒ–**

ğŸ“Œ **é€‚ç”¨åœºæ™¯**ï¼šå½“æ•°æ®æœ‰**ä¸åŒå•ä½**æˆ–**å­˜åœ¨å¼‚å¸¸å€¼**æ—¶ï¼Œæ¯”å¦‚**ç¥ç»ç½‘ç»œè¾“å…¥**

```python
from sklearn.preprocessing import StandardScaler

scaler = StandardScaler()
scaled_data = scaler.fit_transform(data)

print("Z-score æ ‡å‡†åŒ–ç»“æœï¼š\n", scaled_data)
```

------

### æ€»ç»“ï¼š

**ğŸ“Œ é€‰æ‹©å½’ä¸€åŒ–æ–¹æ³•çš„å…³é”®**ï¼š

- **æ·±åº¦å­¦ä¹ ** â†’ ç”¨ **Min-Max å½’ä¸€åŒ–**
- **ç»Ÿè®¡å­¦ä¹ ** â†’ ç”¨ **Z-score æ ‡å‡†åŒ–**
- **æ–‡æœ¬/ç‰¹å¾å‘é‡** â†’ ç”¨ **L2 å½’ä¸€åŒ–**

## **4. å¦‚ä½•è§£å†³æ•°æ®ä¸å¹³è¡¡é—®é¢˜ï¼Ÿ**

### **é¢è¯•è€ƒå¯Ÿç‚¹ï¼š**

- **æ•°æ®ä¸å¹³è¡¡çš„å½±å“**
- **å¦‚ä½•å¤„ç†æ•°æ®ä¸å¹³è¡¡**
- **å®é™…åº”ç”¨ä¸­çš„ä»£ç å®ç°**

------

### **4.1 ä¸ºä»€ä¹ˆæ•°æ®ä¸å¹³è¡¡æ˜¯ä¸ªé—®é¢˜ï¼Ÿ**

æ•°æ®ä¸å¹³è¡¡ï¼ˆæ¯”å¦‚ 90% çš„æ•°æ®æ˜¯ç±»åˆ« Aï¼Œåªæœ‰ 10% æ˜¯ç±»åˆ« Bï¼‰ä¼šå¯¼è‡´æ¨¡å‹**åå‘å¤šæ•°ç±»**ï¼Œå³ï¼š

- **ç²¾ç¡®ç‡ï¼ˆPrecisionï¼‰è¾ƒé«˜ï¼Œä½†å¬å›ç‡ï¼ˆRecallï¼‰è¾ƒä½**ã€‚
- **åˆ†ç±»å™¨å¯èƒ½ä¼šå¿½ç•¥å°‘æ•°ç±»ï¼Œå¯¼è‡´åˆ†ç±»æ•ˆæœä¸ä½³**ã€‚

------

### **4.2 è§£å†³æ•°æ®ä¸å¹³è¡¡çš„å¸¸ç”¨æ–¹æ³•

åœ¨æ•°æ®ä¸å¹³è¡¡çš„æƒ…å†µä¸‹ï¼Œå¸¸ç”¨çš„ Python åº“ä¸»è¦æœ‰ **`imbalanced-learn`**ã€**`scikit-learn`** å’Œ **`numpy`**ã€‚ä»¥ä¸‹æ˜¯æœ€å¸¸ç”¨çš„å‡½æ•°å’Œåº“çš„æ±‡æ€»ï¼ŒåŒ…æ‹¬ **æ¬ é‡‡æ ·ã€è¿‡é‡‡æ ·ã€SMOTEã€ç±»åˆ«æƒé‡è°ƒæ•´ç­‰æ–¹æ³•**ã€‚

| **æ–¹æ³•**                            | **æ ¸å¿ƒæ€è·¯**                       | **é€‚ç”¨åœºæ™¯**                                          |
| ----------------------------------- | ---------------------------------- | ----------------------------------------------------- |
| **æ¬ é‡‡æ ·ï¼ˆUnder-Samplingï¼‰**        | ä»å¤šæ•°ç±»ä¸­éšæœºåˆ é™¤ä¸€éƒ¨åˆ†æ•°æ®       | é€‚ç”¨äºå¤šæ•°ç±»æ•°æ®å¤šï¼Œæ•°æ®é‡‡æ ·ä¸ä¼šå½±å“æ¨¡å‹æ€§èƒ½çš„æƒ…å†µã€‚  |
| **è¿‡é‡‡æ ·ï¼ˆOver-Samplingï¼‰**         | å¤åˆ¶å°‘æ•°ç±»æ ·æœ¬ï¼Œå¢åŠ æ•°æ®æ•°é‡       | é€‚ç”¨äºå°‘æ•°ç±»æ•°æ®å¾ˆå°‘ï¼Œä½†æ¨¡å‹å¯èƒ½å®¹æ˜“è¿‡æ‹Ÿåˆã€‚          |
| **SMOTEï¼ˆåˆæˆå°‘æ•°ç±»è¿‡é‡‡æ ·ï¼‰**       | ç”Ÿæˆæ–°çš„å°‘æ•°ç±»æ ·æœ¬ï¼Œè€Œä¸æ˜¯ç®€å•å¤åˆ¶ | é€‚ç”¨äº**å°‘æ•°ç±»æ•°æ®è¾ƒå°‘**çš„æƒ…å†µã€‚                      |
| **è°ƒæ•´ç±»åˆ«æƒé‡ï¼ˆClass Weightingï¼‰** | è®­ç»ƒæ—¶å¯¹å°‘æ•°ç±»èµ‹äºˆæ›´é«˜æƒé‡         | é€‚ç”¨äº**æ¨¡å‹å¯ä»¥è®¾ç½®æƒé‡**ï¼ˆå¦‚ SVM, Random Forestï¼‰ã€‚ |

------



### 4.3 ä»£ç ç¤ºä¾‹

#### **ğŸ“Œ 1. æ¬ é‡‡æ ·ï¼ˆUnder-Samplingï¼‰**

**ç›®çš„ï¼šå‡å°‘å¤šæ•°ç±»æ ·æœ¬ï¼Œä»¥å¹³è¡¡æ•°æ®é›†**

- **é€‚ç”¨åœºæ™¯**ï¼šå¤šæ•°ç±»æ ·æœ¬å¾ˆå¤šï¼Œå°‘æ•°ç±»æ ·æœ¬è¶³å¤Ÿï¼Œä¸å¸Œæœ›ç”Ÿæˆè™šå‡æ ·æœ¬ã€‚

| **æ–¹æ³•**                | **å‡½æ•°**                      | **åº“**                    |
| ----------------------- | ----------------------------- | ------------------------- |
| **éšæœºæ¬ é‡‡æ ·**          | `RandomUnderSampler()`        | `imblearn.under_sampling` |
| **è¿‘é‚»ç¼–è¾‘æ¬ é‡‡æ ·**      | `EditedNearestNeighbours()`   | `imblearn.under_sampling` |
| **CNNï¼ˆæœ‰æ¡ä»¶è¿‘é‚»æ³•ï¼‰** | `CondensedNearestNeighbour()` | `imblearn.under_sampling` |

```python
from imblearn.under_sampling import RandomUnderSampler
import numpy as np

X = np.array([[i] for i in range(10)])
y = np.array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1])  # 5:5 æ­£è´Ÿæ ·æœ¬å‡è¡¡

rus = RandomUnderSampler(sampling_strategy=0.5)  # è®©å¤šæ•°ç±»æ ·æœ¬å‡å°‘åˆ°å°‘æ•°ç±»çš„ 0.5 å€
X_resampled, y_resampled = rus.fit_resample(X, y)

print("æ¬ é‡‡æ ·åæ•°æ®åˆ†å¸ƒï¼š", np.bincount(y_resampled))
```



#### **ğŸ“Œ 2. è¿‡é‡‡æ ·**

- **ç›®çš„ï¼šå¢åŠ å°‘æ•°ç±»æ ·æœ¬ï¼Œä»¥å¹³è¡¡æ•°æ®é›†**

  - **é€‚ç”¨åœºæ™¯**ï¼šå°‘æ•°ç±»æ ·æœ¬è¾ƒå°‘ï¼Œæ•°æ®é‡ä¸è¶³ï¼Œé¿å…å› æ•°æ®ä¸è¶³å¯¼è‡´æ¨¡å‹å­¦ä¹ æ•ˆæœä¸ä½³ã€‚

  | **æ–¹æ³•**                     | **å‡½æ•°**              | **åº“**                   |
  | ---------------------------- | --------------------- | ------------------------ |
  | **éšæœºè¿‡é‡‡æ ·**               | `RandomOverSampler()` | `imblearn.over_sampling` |
  | **SMOTEï¼ˆåˆæˆå°‘æ•°ç±»æ ·æœ¬ï¼‰**  | `SMOTE()`             | `imblearn.over_sampling` |
  | **ADASYNï¼ˆè‡ªé€‚åº”åˆæˆé‡‡æ ·ï¼‰** | `ADASYN()`            | `imblearn.over_sampling` |

```python
from imblearn.over_sampling import RandomOverSampler

ros = RandomOverSampler(sampling_strategy=1.0)  # è®©ä¸¤ç±»æ ·æœ¬æ•°é‡ç›¸ç­‰
X_resampled, y_resampled = ros.fit_resample(X, y)

print("è¿‡é‡‡æ ·åæ•°æ®åˆ†å¸ƒï¼š", np.bincount(y_resampled))
```



#### ğŸ“Œ 3. SMOTEï¼ˆSynthetic Minority Over-sampling Techniqueï¼‰

**ç›®çš„ï¼šé€šè¿‡åˆæˆæ–°çš„æ ·æœ¬æ¥å¢åŠ å°‘æ•°ç±»æ ·æœ¬æ•°é‡**

- **é€‚ç”¨åœºæ™¯**ï¼šå°‘æ•°ç±»æ ·æœ¬è¿‡å°‘ï¼Œä½†ä¸å¸Œæœ›ç®€å•å¤åˆ¶åŸå§‹æ ·æœ¬ï¼Œè€Œæ˜¯å¸Œæœ›ç”Ÿæˆç›¸ä¼¼çš„æ–°æ ·æœ¬ã€‚

| **æ–¹æ³•**       | **å‡½æ•°**            | **åº“**                   |
| -------------- | ------------------- | ------------------------ |
| **åŸºæœ¬ SMOTE** | `SMOTE()`           | `imblearn.over_sampling` |
| **è¾¹ç•Œ SMOTE** | `BorderlineSMOTE()` | `imblearn.over_sampling` |
| **SVM SMOTE**  | `SVMSMOTE()`        | `imblearn.over_sampling` |

```python
from imblearn.over_sampling import SMOTE

smote = SMOTE(sampling_strategy=1.0)  # ç”Ÿæˆæ–°æ ·æœ¬ï¼Œä½¿ä¸¤ç±»æ•°é‡ç›¸ç­‰
X_resampled, y_resampled = smote.fit_resample(X, y)

print("SMOTE è¿‡é‡‡æ ·åæ•°æ®åˆ†å¸ƒï¼š", np.bincount(y_resampled))
```



#### **ğŸ“Œ 4. è°ƒæ•´ç±»åˆ«æƒé‡**

```python
from sklearn.linear_model import LogisticRegression
from sklearn.utils.class_weight import compute_class_weight

class_weights = compute_class_weight(class_weight="balanced", classes=np.unique(y), y=y)
weights_dict = {cls: weight for cls, weight in zip(np.unique(y), class_weights)}

# ä½¿ç”¨æƒé‡è¿›è¡Œè®­ç»ƒ
model = LogisticRegression(class_weight=weights_dict)
model.fit(X, y)
```

------



#### ğŸ“Œ **5. è¯„ä¼°æ•°æ®ä¸å¹³è¡¡é—®é¢˜**

**ç›®çš„ï¼šä½¿ç”¨åˆé€‚çš„è¯„ä»·æŒ‡æ ‡è¡¡é‡æ•°æ®ä¸å¹³è¡¡æ¨¡å‹çš„è¡¨ç°**

- **é€‚ç”¨åœºæ™¯**ï¼šæ•°æ®ä¸å¹³è¡¡æ—¶ï¼Œä¸é€‚åˆç”¨ Accuracyï¼Œéœ€è¦ç”¨ Precision, Recall, F1-score, AUC-ROCã€‚

| **æ–¹æ³•**                             | **å‡½æ•°**                  | **åº“**            |
| ------------------------------------ | ------------------------- | ----------------- |
| **è®¡ç®— Precisionã€Recallã€F1-score** | `classification_report()` | `sklearn.metrics` |
| **è®¡ç®— AUC-ROC**                     | `roc_auc_score()`         | `sklearn.metrics` |
| **ç»˜åˆ¶ ROC æ›²çº¿**                    | `roc_curve()`             | `sklearn.metrics` |

**ç¤ºä¾‹ä»£ç ï¼š**

```pythonÂ 
from sklearn.metrics import classification_report, roc_auc_score, roc_curve

y_pred = model.predict(X)

# è®¡ç®— Precision, Recall, F1-score
print(classification_report(y, y_pred))

# è®¡ç®— AUC-ROC
auc = roc_auc_score(y, model.predict_proba(X)[:, 1])
print("AUC-ROC:", auc)
```



## **ğŸ“Œ å¤„ç†æ•°æ®ä¸å¹³è¡¡çš„å¸¸ç”¨åº“æ€»ç»“**

| **ç±»åˆ«**         | **å¸¸ç”¨åº“**                   |
| ---------------- | ---------------------------- |
| **æ¬ é‡‡æ ·**       | `imblearn.under_sampling`    |
| **è¿‡é‡‡æ ·**       | `imblearn.over_sampling`     |
| **SMOTE**        | `imblearn.over_sampling`     |
| **ç»„åˆé‡‡æ ·**     | `imblearn.combine`           |
| **ç±»åˆ«æƒé‡è°ƒæ•´** | `sklearn.utils.class_weight` |
| **è¯„ä¼°æŒ‡æ ‡**     | `sklearn.metrics`            |

------

## **ğŸ¯ æ€»ç»“**

- **æ¬ é‡‡æ ·** (`RandomUnderSampler`)ï¼šé€‚ç”¨äºå¤šæ•°ç±»æ ·æœ¬è¿‡å¤šçš„æƒ…å†µã€‚
- **è¿‡é‡‡æ ·** (`RandomOverSampler`)ï¼šé€‚ç”¨äºå°‘æ•°ç±»æ ·æœ¬è¿‡å°‘ä½†æ•°æ®ä¸å¤æ‚çš„æƒ…å†µã€‚
- **SMOTE** (`SMOTE`)ï¼šé€‚ç”¨äºå°‘æ•°ç±»æ•°æ®è¾ƒå°‘ä½†éœ€è¦ç”Ÿæˆåˆæˆæ ·æœ¬çš„æƒ…å†µã€‚
- **ç»„åˆé‡‡æ ·** (`SMOTEENN`)ï¼šé€‚ç”¨äºæ•°æ®æç«¯ä¸å¹³è¡¡çš„æƒ…å†µã€‚
- **è°ƒæ•´ç±»åˆ«æƒé‡**ï¼ˆ`class_weight`ï¼‰ï¼šé€‚ç”¨äºä¸å¸Œæœ›ä¿®æ”¹æ•°æ®åˆ†å¸ƒçš„æƒ…å†µã€‚
- **è¯„ä¼°æ–¹æ³•**ï¼ˆ`classification_report, roc_auc_score`ï¼‰ï¼šåœ¨ä¸å¹³è¡¡æ•°æ®é›†ä¸Šä½¿ç”¨ F1-score å’Œ AUC-ROCã€‚



## **ğŸ¯ æ€»ç»“**å½’ä¸€åŒ–å’Œæ•°æ®ä¸å¹³è¡¡é—®é¢˜ï¼š

### **ğŸ“Œ 3. ä¸ºä»€ä¹ˆè¦åšå½’ä¸€åŒ–ï¼Ÿ**

- **åŠ é€Ÿæ¢¯åº¦ä¸‹é™ï¼Œæé«˜æ¨¡å‹æ”¶æ•›é€Ÿåº¦**ã€‚

- **é¿å…æŸäº›ç‰¹å¾å€¼è¿‡å¤§å½±å“æ¨¡å‹è®­ç»ƒ**ã€‚

- **è®©æ¨¡å‹å¯¹ä¸åŒç‰¹å¾çš„æƒé‡æ›´åŠ å‡è¡¡**ã€‚

- å¸¸ç”¨æ–¹æ³•ï¼š

  - **Min-Max å½’ä¸€åŒ–**ï¼ˆé€‚ç”¨äºæ•°å€¼èŒƒå›´å·²çŸ¥çš„æƒ…å†µï¼‰
  - **Z-score æ ‡å‡†åŒ–**ï¼ˆé€‚ç”¨äºæ­£æ€åˆ†å¸ƒæ•°æ®ï¼‰
  - **Log å½’ä¸€åŒ–**ï¼ˆé€‚ç”¨äºæŒ‡æ•°å¢é•¿æ•°æ®ï¼‰
  - **Robust å½’ä¸€åŒ–**ï¼ˆé€‚ç”¨äºæœ‰æç«¯å€¼çš„æ•°æ®ï¼‰

------

### **ğŸ“Œ 4. å¦‚ä½•è§£å†³æ•°æ®ä¸å¹³è¡¡é—®é¢˜ï¼Ÿ**

- **æ¬ é‡‡æ ·**ï¼ˆåˆ é™¤éƒ¨åˆ†å¤šæ•°ç±»æ•°æ®ï¼‰
- **è¿‡é‡‡æ ·**ï¼ˆå¤åˆ¶å°‘æ•°ç±»æ•°æ®ï¼‰
- **SMOTE**ï¼ˆåˆæˆæ–°çš„å°‘æ•°ç±»æ ·æœ¬ï¼‰
- **è°ƒæ•´ç±»åˆ«æƒé‡**ï¼ˆç»™å°‘æ•°ç±»æ›´é«˜æƒé‡ï¼‰

âœ… **é¢è¯•å»ºè®®**ï¼š

- **å½’ä¸€åŒ–ï¼šç†è§£ä¸åŒæ–¹æ³•çš„åº”ç”¨åœºæ™¯ï¼Œèƒ½å¤Ÿè§£é‡Šå…¶æ•°å­¦åŸç†ã€‚**
- **æ•°æ®ä¸å¹³è¡¡ï¼šç†è§£æ•°æ®åå·®çš„å½±å“ï¼Œå¹¶èƒ½é€‰æ‹©åˆé€‚çš„å¤„ç†æ–¹æ³•ã€‚**
- **èƒ½å¤Ÿå†™å‡ºä»£ç å®ç°ï¼ˆå¦‚ `scikit-learn` æˆ– `imblearn` çš„æ–¹æ³•ï¼‰ã€‚**



