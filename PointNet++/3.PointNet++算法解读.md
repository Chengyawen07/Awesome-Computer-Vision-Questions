# **3. PointNet++ ç®—æ³•è§£è¯»**

**PointNet++** æ˜¯ **PointNet** çš„å‡çº§ç‰ˆï¼Œè§£å†³äº† **PointNet åªæå–å…¨å±€ç‰¹å¾ã€ç¼ºä¹å±€éƒ¨ä¿¡æ¯** çš„é—®é¢˜ï¼Œä½¿ç”¨ **"åˆ†ç»„ + é‡‡æ · + å±‚æ¬¡åŒ–ç‰¹å¾æå–"** è®© 3D ç‚¹äº‘åˆ†ç±»å’Œåˆ†å‰²æ›´åŠ ç²¾å‡†ã€‚

------

## **1ï¸âƒ£ ä»€ä¹ˆæ˜¯ PointNet++ï¼Ÿ**

âœ… **PointNet++ = PointNet + å±‚æ¬¡åŒ–å±€éƒ¨ç‰¹å¾æå–**
 âœ… **æ ¸å¿ƒæ€æƒ³**ï¼š

- **å…ˆåˆ†ç»„ï¼Œå†æå–å±€éƒ¨ç‰¹å¾ï¼Œæœ€åæ•´åˆæˆå…¨å±€ç‰¹å¾**
- **ç±»ä¼¼äºäººç±»è§‚å¯Ÿç‰©ä½“ï¼Œå…ˆçœ‹ç»†èŠ‚ï¼Œå†çœ‹æ•´ä½“**
- **è§£å†³ PointNet å¿½ç•¥å±€éƒ¨ä¿¡æ¯çš„é—®é¢˜**

------

## **2ï¸âƒ£ PointNet++ çš„æ ¸å¿ƒæ­¥éª¤**

PointNet++ ä¸»è¦æœ‰ 3 ä¸ªæ ¸å¿ƒæ­¥éª¤ï¼š 

1ï¸âƒ£ **æœ€è¿œç‚¹é‡‡æ ·ï¼ˆFPS, Farthest Point Samplingï¼‰** â†’ é€‰å‡ºä»£è¡¨æ€§ä¸­å¿ƒç‚¹
 2ï¸âƒ£ **å±€éƒ¨åˆ†ç»„ï¼ˆGroupingï¼‰** â†’ é€‰å–æ¯ä¸ªä¸­å¿ƒç‚¹å‘¨å›´çš„é‚»å±…ç‚¹
 3ï¸âƒ£ **å±€éƒ¨ç‰¹å¾æå–ï¼ˆLocal Feature Extractionï¼‰** â†’ è¿è¡Œ PointNet æå–ç‰¹å¾

ğŸ“Œ **ç®€å•ç†è§£**

- å…ˆæŠŠç‚¹äº‘åˆ†æˆ **å¤šä¸ªå°åŒºåŸŸï¼ˆå±€éƒ¨ç°‡ï¼‰**
- åœ¨æ¯ä¸ªåŒºåŸŸå†…ç”¨ **PointNet æå–ç‰¹å¾**
- é€æ­¥åˆå¹¶å±€éƒ¨ä¿¡æ¯ï¼Œå½¢æˆå…¨å±€ç‰¹å¾

------



## **3ï¸âƒ£ PointNet++ å…³é”®æŠ€æœ¯**

### **(1) æœ€è¿œç‚¹é‡‡æ ·ï¼ˆFPS, Farthest Point Samplingï¼‰**

**ğŸ“Œ ä½œç”¨**ï¼š

- è®©é‡‡æ ·ç‚¹å‡åŒ€åˆ†å¸ƒï¼Œé¿å…é›†ä¸­åœ¨ä¸€ä¸ªåŒºåŸŸ

**ğŸ“Œ ä»£ç ç¤ºä¾‹**

```python
import numpy as np

def farthest_point_sampling(points, num_samples):
    sampled = []
    sampled.append(points[0])  # å…ˆé€‰ä¸€ä¸ªç‚¹
    for _ in range(num_samples - 1):
        dists = np.linalg.norm(points - sampled[-1], axis=1)
        next_point = points[np.argmax(dists)]
        sampled.append(next_point)
    return np.array(sampled)

points = np.random.rand(1024, 3)  # 1024 ä¸ªç‚¹
sampled_points = farthest_point_sampling(points, 128)  # é‡‡æ · 128 ä¸ªç‚¹
```

------



### **(2) å±€éƒ¨åˆ†ç»„ï¼ˆGroupingï¼‰**

**ğŸ“Œ ä½œç”¨**ï¼š

- é€‰å®šä¸­å¿ƒç‚¹åï¼Œæ‰¾åˆ°å…¶ **å‘¨å›´çš„ç‚¹ï¼ˆå±€éƒ¨ç°‡ï¼‰** è¿›è¡Œç‰¹å¾æå–

**ğŸ“Œ ä»£ç ç¤ºä¾‹**

```python
from sklearn.neighbors import NearestNeighbors

def radius_grouping(points, centers, radius):
    neigh = NearestNeighbors(radius=radius)
    neigh.fit(points)
    grouped_points = [points[neigh.radius_neighbors([c], return_distance=False)[0]] for c in centers]
    return grouped_points

centers = sampled_points  # 128 ä¸ªä¸­å¿ƒç‚¹
groups = radius_grouping(points, centers, radius=0.2)  # åœ¨ 0.2 èŒƒå›´å†…é€‰æ‹©é‚»å±…ç‚¹
```

------



### **(3) å±€éƒ¨ç‰¹å¾æå–ï¼ˆPointNet å±‚ï¼‰**

**ğŸ“Œ ä½œç”¨**ï¼š

- å¯¹æ¯ä¸ªå±€éƒ¨ç°‡ **ç”¨ MLP æå–ç‰¹å¾**ï¼Œç„¶å **Max Pooling å–æœ€é‡è¦çš„ç‰¹å¾**
- **è¾“å‡ºï¼šæ¯ä¸ªå±€éƒ¨ç°‡å˜æˆä¸€ä¸ªé«˜ç»´ç‰¹å¾å‘é‡**

**ğŸ“Œ ä»£ç ç¤ºä¾‹**

```python
import torch.nn as nn

class PointNetLayer(nn.Module):
    def __init__(self, in_dim, out_dim):
        super(PointNetLayer, self).__init__()
        self.mlp = nn.Sequential(
            nn.Linear(in_dim, 64),
            nn.ReLU(),
            nn.Linear(64, out_dim),
            nn.ReLU()
        )

    def forward(self, x):
        return torch.max(self.mlp(x), dim=1)[0]  # Max Pooling èšåˆç‰¹å¾
```

------

